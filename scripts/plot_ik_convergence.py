#!/usr/bin/env python3

import argparse
import os
import sys
from glob import glob


def read_meta(csv_path: str):
    meta = {}
    with open(csv_path, "r", encoding="utf-8") as f:
        for line in f:
            if not line.startswith("#"):
                break
            line = line[1:].strip()  # strip leading '#'
            if not line:
                continue
            if "=" not in line:
                continue
            key, value = line.split("=", 1)
            meta[key.strip()] = value.strip()
    return meta


def find_latest_timestamped_csv_pair(directory: str):
    pattern = os.path.join(directory, "*_ik_dls_position_convergence.csv")
    candidates = sorted(glob(pattern))
    if not candidates:
        return None, None, None

    pos_csv = candidates[-1]
    prefix = os.path.basename(pos_csv).replace("_ik_dls_position_convergence.csv", "")
    rot_csv = os.path.join(directory, f"{prefix}_ik_dls_rotation_convergence.csv")
    if not os.path.exists(rot_csv):
        rot_csv = None
    return prefix, pos_csv, rot_csv


def safe_float(value: str):
    try:
        return float(value)
    except Exception:
        return None


def read_dataframe(csv_path: str):
    """Read a CSV into a DataFrame, ignoring '#' comment lines."""
    try:
        import pandas as pd

        return pd.read_csv(csv_path, comment="#")
    except ModuleNotFoundError:
        # Keep script usable even without pandas.
        import csv

        rows = []
        with open(csv_path, "r", encoding="utf-8") as f:
            for line in f:
                if line.lstrip().startswith("#") or not line.strip():
                    continue
                rows.append(line)

        reader = csv.DictReader(rows)
        return list(reader)


def main() -> int:
    ap = argparse.ArgumentParser(
        description=(
            "Plot IK DLS convergence from CSV. With no arguments, reads "
            "the latest timestamped CSVs from docs/evaluation/ and writes both plots under docs/evaluation/."
        )
    )
    ap.add_argument(
        "--csv",
        default="docs/evaluation",
        help=(
            "Path to CSV generated by ik_convergence_eval, or a directory containing timestamped CSVs "
            "(default: docs/evaluation)"
        ),
    )
    ap.add_argument(
        "--out",
        default="docs/evaluation/ik_dls_convergence.png",
        help="Output position plot path (.png or .pdf). Parent directories are created.",
    )
    args = ap.parse_args()

    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        print(
            "matplotlib is required to generate the plot. Install e.g. 'python3-matplotlib' (APT) "
            "or 'pip install matplotlib'.\n\n"
            f"Import error: {e}",
            file=sys.stderr,
        )
        return 2

    # Derive rotation CSV + output paths automatically.
    csv_arg = args.csv
    out_pos = args.out

    if os.path.isdir(csv_arg):
        prefix, csv_pos, csv_rot = find_latest_timestamped_csv_pair(csv_arg)
        if csv_pos is None:
            # Fall back to legacy single CSV name.
            csv_pos = os.path.join(csv_arg, "ik_dls_convergence.csv")
            csv_rot = os.path.join(csv_arg, "ik_dls_rotation_convergence.csv")
            prefix = None
        out_dir = os.path.dirname(out_pos) or csv_arg
    else:
        csv_pos = csv_arg
        out_dir = os.path.dirname(out_pos) or os.path.dirname(csv_pos) or "."
        prefix = None
        csv_rot = os.path.join(os.path.dirname(csv_pos) or ".", "ik_dls_rotation_convergence.csv")

    if prefix:
        out_pos = os.path.join(out_dir, f"{prefix}_ik_dls_position_convergence.png")
        out_rot = os.path.join(out_dir, f"{prefix}_ik_dls_rotation_convergence.png")
    else:
        out_rot = os.path.join(out_dir, "ik_dls_rotation_convergence.png")

    meta_pos = read_meta(csv_pos) if os.path.exists(csv_pos) else {}
    meta_rot = read_meta(csv_rot) if (csv_rot and os.path.exists(csv_rot)) else {}

    pos_tol = safe_float(meta_pos.get("ik.pos_tol"))
    rot_tol = safe_float(meta_rot.get("ik.rot_tol"))
    if rot_tol is None:
        rot_tol = safe_float(meta_pos.get("ik.rot_tol"))

    os.makedirs(out_dir, exist_ok=True)

    # Position plot (from main CSV)
    df_pos = read_dataframe(csv_pos)
    if isinstance(df_pos, list):
        it_pos = [int(r["iteration"]) for r in df_pos]
        pos_err = [float(r["pos_err_m"]) for r in df_pos]
    else:
        it_pos = df_pos["iteration"].to_numpy()
        pos_err = df_pos["pos_err_m"].to_numpy()

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(it_pos, pos_err, linewidth=2.0)
    if pos_tol is not None:
        ax.axhline(pos_tol, linestyle="--", linewidth=1.0, label=f"pos_tol={pos_tol:g} m")
    ax.set_xlabel("Iteration")
    ax.set_ylabel("Position error (m)")
    ax.grid(True, which="both", linestyle="-", linewidth=0.5, alpha=0.3)
    if pos_tol is not None:
        ax.legend(loc="best")

    fig.tight_layout()
    fig.savefig(out_pos, dpi=160)
    print(f"Wrote plot to {out_pos}")

    # Rotation plot (prefer rotation-only CSV; fall back to main CSV)
    rot_source = csv_rot if (csv_rot and os.path.exists(csv_rot)) else csv_pos
    df_rot = read_dataframe(rot_source)
    if isinstance(df_rot, list):
        it_rot = [int(r["iteration"]) for r in df_rot]
        if "rot_err_rad" in (df_rot[0].keys() if df_rot else []):
            rot_err = [float(r["rot_err_rad"]) for r in df_rot]
        else:
            # rotation-only CSV uses iteration,rot_err_rad
            rot_err = [float(r["rot_err_rad"]) for r in df_rot]
    else:
        it_rot = df_rot["iteration"].to_numpy()
        rot_err = df_rot["rot_err_rad"].to_numpy()

    fig2, ax2 = plt.subplots(figsize=(6, 4))
    ax2.plot(it_rot, rot_err, linewidth=2.0)
    if rot_tol is not None:
        ax2.axhline(rot_tol, linestyle="--", linewidth=1.0, label=f"rot_tol={rot_tol:g} rad")
    ax2.set_xlabel("Iteration")
    ax2.set_ylabel("Rotation error (rad)")
    ax2.grid(True, which="both", linestyle="-", linewidth=0.5, alpha=0.3)
    if rot_tol is not None:
        ax2.legend(loc="best")

    fig2.tight_layout()
    fig2.savefig(out_rot, dpi=160)
    print(f"Wrote plot to {out_rot}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
