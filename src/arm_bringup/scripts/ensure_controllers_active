#!/usr/bin/env python3

import time
from typing import Dict, List, Optional

import rclpy
from builtin_interfaces.msg import Duration
from controller_manager_msgs.srv import (
    ConfigureController,
    ListControllers,
    LoadController,
    SwitchController,
)
from rclpy.node import Node


def _now_monotonic() -> float:
    return time.monotonic()


class EnsureControllersActive(Node):
    def __init__(self) -> None:
        super().__init__("ensure_controllers_active")

        def _param_str(name: str, default: str) -> str:
            value = self.get_parameter(name).value
            return default if value is None else str(value)

        def _param_float(name: str, default: float) -> float:
            value = self.get_parameter(name).value
            if value is None:
                return float(default)
            try:
                if isinstance(value, (int, float)):
                    return float(value)
                return float(str(value))
            except (TypeError, ValueError):
                return float(default)

        def _param_str_list(name: str, default: list[str]) -> list[str]:
            value = self.get_parameter(name).value
            if value is None:
                return list(default)
            if isinstance(value, (list, tuple)):
                return [str(v) for v in value]
            return [str(value)]

        self.declare_parameter("controller_manager", "/controller_manager")
        self.declare_parameter(
            "controllers",
            ["joint_state_broadcaster", "joint_trajectory_controller"],
        )
        self.declare_parameter("timeout_s", 60.0)
        self.declare_parameter("poll_period_s", 0.5)
        self.declare_parameter("switch_timeout_s", 30.0)

        self._cm = _param_str("controller_manager", "/controller_manager")
        self._controllers = _param_str_list(
            "controllers",
            ["joint_state_broadcaster", "joint_trajectory_controller"],
        )
        self._timeout_s = _param_float("timeout_s", 60.0)
        self._poll_period_s = _param_float("poll_period_s", 0.5)
        self._switch_timeout_s = _param_float("switch_timeout_s", 30.0)

        # Services are under controller manager namespace.
        self._list_cli = self.create_client(ListControllers, f"{self._cm}/list_controllers")
        self._load_cli = self.create_client(LoadController, f"{self._cm}/load_controller")
        self._cfg_cli = self.create_client(ConfigureController, f"{self._cm}/configure_controller")
        self._switch_cli = self.create_client(SwitchController, f"{self._cm}/switch_controller")

    def _wait_for_services(self, deadline: float) -> bool:
        for cli, name in [
            (self._list_cli, "list_controllers"),
            (self._load_cli, "load_controller"),
            (self._cfg_cli, "configure_controller"),
            (self._switch_cli, "switch_controller"),
        ]:
            while not cli.wait_for_service(timeout_sec=0.2):
                if _now_monotonic() >= deadline:
                    self.get_logger().error(f"Timeout waiting for {self._cm}/{name}")
                    return False
        return True

    def _call(self, cli, req, deadline: float):
        future = cli.call_async(req)
        while rclpy.ok() and not future.done():
            if _now_monotonic() >= deadline:
                return None
            rclpy.spin_once(self, timeout_sec=0.1)
        return future.result() if future.done() else None

    def _list(self, deadline: float) -> Optional[Dict[str, str]]:
        resp = self._call(self._list_cli, ListControllers.Request(), deadline)
        if resp is None:
            return None
        return {c.name: c.state for c in resp.controller}

    def _ensure_loaded(self, name: str, deadline: float) -> bool:
        req = LoadController.Request()
        req.name = name
        resp = self._call(self._load_cli, req, deadline)
        if resp is None:
            return False
        return bool(resp.ok)

    def _ensure_configured(self, name: str, deadline: float) -> bool:
        req = ConfigureController.Request()
        req.name = name
        resp = self._call(self._cfg_cli, req, deadline)
        if resp is None:
            return False
        return bool(resp.ok)

    def _activate(self, names: List[str], deadline: float) -> bool:
        if not names:
            return True
        req = SwitchController.Request()
        req.activate_controllers = names
        req.deactivate_controllers = []
        req.strictness = SwitchController.Request.STRICT
        req.activate_asap = True

        # rclpy expects builtin_interfaces/msg/Duration here.
        timeout_s = max(0.0, float(self._switch_timeout_s))
        timeout_sec = int(timeout_s)
        timeout_nanosec = int((timeout_s - timeout_sec) * 1e9)
        req.timeout = Duration(sec=timeout_sec, nanosec=timeout_nanosec)
        resp = self._call(self._switch_cli, req, deadline)
        if resp is None:
            return False
        return bool(resp.ok)

    def run(self) -> int:
        if not self._controllers:
            self.get_logger().warn("No controllers requested; exiting.")
            return 0

        start = _now_monotonic()
        deadline = start + self._timeout_s

        self.get_logger().info(
            f"Ensuring controllers ACTIVE via {self._cm}: {', '.join(self._controllers)}"
        )

        if not self._wait_for_services(deadline):
            return 1

        last_states: Optional[Dict[str, str]] = None

        while rclpy.ok() and _now_monotonic() < deadline:
            states = self._list(deadline)
            if states is None:
                time.sleep(self._poll_period_s)
                continue

            last_states = states

            # Load missing controllers.
            for name in self._controllers:
                if name not in states:
                    self.get_logger().info(f"Loading controller '{name}'...")
                    if not self._ensure_loaded(name, deadline):
                        self.get_logger().warn(f"Load failed for '{name}', will retry")
                    # Refresh list in next loop.
                    break

            states = self._list(deadline)
            if states is None:
                time.sleep(self._poll_period_s)
                continue

            # Configure unconfigured controllers.
            for name in self._controllers:
                state = states.get(name)
                if state == "unconfigured":
                    self.get_logger().info(f"Configuring controller '{name}'...")
                    if not self._ensure_configured(name, deadline):
                        self.get_logger().warn(f"Configure failed for '{name}', will retry")
                    break

            states = self._list(deadline)
            if states is None:
                time.sleep(self._poll_period_s)
                continue

            # Activate everything that isn't active yet.
            to_activate = [
                name for name in self._controllers if states.get(name) not in (None, "active")
            ]
            if to_activate:
                self.get_logger().info(f"Activating controllers: {', '.join(to_activate)}")
                if not self._activate(to_activate, deadline):
                    self.get_logger().warn("Switch (activate) failed, will retry")

            states = self._list(deadline)
            if states is None:
                time.sleep(self._poll_period_s)
                continue

            if all(states.get(name) == "active" for name in self._controllers):
                self.get_logger().info("All requested controllers are ACTIVE.")
                return 0

            time.sleep(self._poll_period_s)

        self.get_logger().error(
            f"Timeout ensuring controllers ACTIVE after {self._timeout_s:.1f}s. Last states: {last_states}"
        )
        return 1


def main() -> None:
    rclpy.init()
    node = EnsureControllersActive()
    try:
        rc = node.run()
    except KeyboardInterrupt:
        rc = 130
    finally:
        node.destroy_node()
        rclpy.shutdown()
    raise SystemExit(rc)


if __name__ == "__main__":
    main()
